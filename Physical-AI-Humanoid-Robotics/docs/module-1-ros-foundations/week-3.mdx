---
sidebar_position: 3
title: 'Week 3: Services, Actions, & Launch Files'
---

# Week 3: Services, Actions, & Launch Files

In the past two weeks, we've focused on the publish-subscribe pattern with Nodes and Topics, which is great for continuous data streams. This week, we'll explore two other crucial communication patterns: Services for request/response interactions and Actions for long-running tasks. We'll also learn how to manage our growing collection of nodes with Launch Files.

## Services: The Request/Response Model

While Topics are for one-way, many-to-many data streams, **Services** are for synchronous, two-way communication. When a node (the client) calls a service, it sends a request and waits for a single response from the service provider (the server).

### Creating a Service

Let's build a simple service that adds two integers.

1.  **Define the Service Interface**: First, we need a `.srv` file to define the structure of the request and response. Create a new directory `srv` in your `py_hello_world` package and add `AddTwoInts.srv`:

    ```srv
    # srv/AddTwoInts.srv
    int64 a
    int64 b
    ---
    int64 sum
    ```
    The section above `---` is the request; the section below is the response.

2.  **Update `CMakeLists.txt` and `package.xml`**: You must tell ROS 2 to build this new interface file.
    - Add `<depend>rosidl_default_generators</depend>` and `<member_of_group>rosidl_interface_packages</member_of_group>` to `package.xml`.
    - Add `rosidl_generate_interfaces(${PROJECT_NAME} "srv/AddTwoInts.srv")` to `CMakeLists.txt` (yes, even for a Python package!).

3.  **Create the Service Server Node**:

    ```python
    # py_hello_world/add_two_ints_server.py
    import rclpy
    from rclpy.node import Node
    from your_package_name.srv import AddTwoInts # Replace your_package_name

    class AddTwoIntsServer(Node):
        def __init__(self):
            super().__init__('add_two_ints_server')
            self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)
            self.get_logger().info('Add Two Ints service is ready.')

        def add_two_ints_callback(self, request, response):
            response.sum = request.a + request.b
            self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}. Returning sum={response.sum}')
            return response

    # ... main function ...
    ```

4.  **Create the Service Client Node**:

    ```python
    # py_hello_world/add_two_ints_client.py
    # ... imports ...

    class AddTwoIntsClient(Node):
        def __init__(self):
            super().__init__('add_two_ints_client')
            self.client = self.create_client(AddTwoInts, 'add_two_ints')
            while not self.client.wait_for_service(timeout_sec=1.0):
                self.get_logger().info('Service not available, waiting again...')
            self.req = AddTwoInts.Request()

        def send_request(self, a, b):
            self.req.a = a
            self.req.b = b
            self.future = self.client.call_async(self.req)
            rclpy.spin_until_future_complete(self, self.future)
            return self.future.result()
            
    # ... main function with logic to call send_request ...
    ```

## Introduction to Launch Files

As you create more nodes, running each in a separate terminal becomes tedious. **Launch Files** solve this by allowing you to define, configure, and run a whole system of nodes with a single command.

Launch files are written in Python. Here's how to create one to run our original `talker` and `listener`.

1.  **Create the Launch Directory**: `mkdir src/py_hello_world/launch`
2.  **Create the Launch File**:

    ```python
    # launch/hello_world.launch.py
    from launch import LaunchDescription
    from launch_ros.actions import Node

    def generate_launch_description():
        return LaunchDescription([
            Node(
                package='py_hello_world',
                executable='talker',
                name='my_talker'
            ),
            Node(
                package='py_hello_world',
                executable='listener',
                name='my_listener'
            ),
        ])
    ```
3.  **Update `setup.py`**: Tell `colcon` where to find your launch files.
    ```python
    # Add to data_files list in setup.py
    (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*.launch.py'))),
    ```
4.  **Build and Launch**: After rebuilding with `colcon build`, you can run everything with:
    ```bash
    ros2 launch py_hello_world hello_world.launch.py
    ```
    You will see the output from both nodes in a single terminal!

## Actions: For Long-Running Goals

**Actions** are the most complex communication type, designed for long-running tasks where you need continuous feedback and the ability to cancel the goal. Think "navigate to the kitchen" or "pick up an object."

An Action involves:
- An **Action Server** that executes the task.
- An **Action Client** that requests the task.
- A **Goal**: What the client wants to achieve.
- **Feedback**: Intermediate updates from the server.
- A **Result**: The final outcome from the server.

Due to their complexity, we will dedicate a full week to Actions in a later module. For now, it's important to know they exist for tasks that don't fit the simple request/response pattern of Services.

## Exercises

1.  Add the `add_two_ints_server.py` and `add_two_ints_client.py` nodes to your `py_hello_world` package. Don't forget to update `setup.py`!
2.  After building and sourcing your workspace, run the service server in one terminal. In another, use the `ros2 service call` command-line tool to test it.
    ```bash
    ros2 service call /add_two_ints your_package_name/srv/AddTwoInts "{a: 5, b: 10}"
    ```
3.  Modify your `hello_world.launch.py` file to also launch your `add_two_ints_server` node.
4.  Why is a launch file more convenient than running each node manually?
